---
layout: post
title:  "Java 运算符与流程控制（二）：关系、逻辑、位运算与 Integer 缓存池"
date:    2025-11-19 10:00:00 +0800
categories: [Java, 核心技术, 底层原理]
tags: [运算符, 位运算, 短路逻辑, IntegerCache, 源码分析]
---

## 系列回顾

在上一篇中，我们深入了算术运算符的截断问题、隐式类型提升的规则，以及 `i++` 在字节码层面的执行顺序。今天，我们继续拆解运算符家族的另外三个重要成员：关系、逻辑与位运算。它们看似简单，但隐藏的性能优化技巧和内存陷阱却往往决定了代码的成败。

---

## 第二章：关系运算符 (Relational Operators)

`==`, `!=`, `>`, `<`, `>=`, `<=`。这些运算符用于比较两个值，返回 `boolean` 结果。

### 2.1 `==` 的本质与 `equals()` 的契约

这是 Java 初学者最容易混淆，也是资深开发者在 Wrapper Class（包装类）上容易翻车的地方。

* **基本数据类型**：`==` 比较的是**值**。
* **引用数据类型**：`==` 比较的是**内存地址**（即是否指向堆内存中的同一个对象）。

#### 1. 深度剖析：`Integer` 缓存池 (Integer Cache)

请看这道经典的面试题：

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b); // true

Integer c = 128;
Integer d = 128;
System.out.println(c == d); // false !!!
````

  * **现象**：为什么 127 相等，128 就不相等了？
  * **源码分析**：
      * 当执行 `Integer a = 127;` 时，发生了**自动装箱 (Auto-boxing)**。编译器调用的是 `Integer.valueOf(127)`。
      * 查看 JDK `Integer.java` 源码：
        ```java
        public static Integer valueOf(int i) {
            if (i >= IntegerCache.low && i <= IntegerCache.high)
                return IntegerCache.cache[i + (-IntegerCache.low)];
            return new Integer(i);
        }
        ```
      * **IntegerCache**：JVM 启动时，会默认创建一个从 **-128 到 127** 的 `Integer` 对象数组（缓存池）。
      * **127** 在缓存范围内，直接返回缓存数组中的同一个对象引用。所以 `a == b` (地址相同)。
      * **128** 超出范围，代码执行 `new Integer(128)`，在堆上分配了两个全新的对象。所以 `c == d` (地址不同)。

> **最佳实践**：**所有对象类型的比较（包括包装类），严禁使用 `==`，必须使用 `equals()` 或 `Objects.equals(a, b)`。** 只有当你确实需要判断两个引用是否指向同一个对象实例时，才使用 `==`。

-----

## 第三章：逻辑运算符 (Logical Operators)

`&&` (逻辑与), `||` (逻辑或), `!` (逻辑非)。

### 3.1 短路逻辑 (Short-circuiting) 的性能意义

Java 的逻辑运算符是“短路”的，这意味着一旦左边的表达式能确定最终结果，右边的表达式**根本不会执行**。

  * `A && B`：如果 A 为 `false`，结果必为 `false`，B 不执行。
  * `A || B`：如果 A 为 `true`，结果必为 `true`，B 不执行。

#### 1\. 防御性编程的基石

短路不仅仅是性能优化，更是防止异常的关键手段。

```java
// 场景：判断字符串不为空且长度大于 5
String str = null;

// 写法 1 (安全)
if (str != null && str.length() > 5) { ... }
// 分析：str 为 null，左边为 false，直接短路。右边 str.length() 不会执行，避免了 NPE。

// 写法 2 (危险！位运算符 &)
if (str != null & str.length() > 5) { ... }
// 分析：& 是非短路的。即使左边 false，右边 str.length() 依然会强行执行，抛出 NullPointerException。
```

### 3.2 `|` 与 `&` 用在布尔值上

许多人以为 `&` 和 `|` 只能用于位运算。其实，当操作数是 `boolean` 时，它们表示**非短路逻辑运算**。
虽然语法允许，但**极度不推荐**在逻辑判断中使用，除非你有特殊的业务需求（例如：无论左边结果如何，右边的函数必须被执行以产生副作用）。

-----

## 第四章：位运算符 (Bitwise Operators) —— 接近硬件的魔法

位运算符直接对整数在内存中的**二进制位**进行操作。这是 Java 中执行效率最高的操作，也是阅读 JDK 源码（如 HashMap, ThreadPoolExecutor）的门槛。

| 符号 | 名称 | 描述 | 规则 (0为假, 1为真) |
| :--- | :--- | :--- | :--- |
| `&` | 按位与 | 清零器 | 全1则1，有0则0 |
| `|` | 按位或 | 染色器 | 有1则1，全0则0 |
| `^` | 按位异或 | 翻转器 | 相同为0，不同为1 |
| `~` | 按位取反 | 变形器 | 0变1，1变0 |
| `<<` | 左移 | 乘法器 | 左移n位，低位补0 |
| `>>` | 有符号右移 | 除法器 | 右移n位，高位补符号位 |
| `>>>`| 无符号右移 | 逻辑右移 | 右移n位，**高位永远补0** |

### 4.1 移位运算符的细节

#### 1\. 左移 `<<` (乘 2 的幂)

`m << n` 等价于 `m * 2^n`。

  * **面试题**：计算 2 \* 8 最快的方法？
  * **答**：`2 << 3`。因为 CPU 执行位移指令比乘法指令快得多。

#### 2\. 有符号右移 `>>` vs 无符号右移 `>>>`

  * **`>>` (Arithmetic Shift)**：保留符号位。
      * `10 >> 1` (二进制 `...001010` -\> `...000101`) = 5
      * `-10 >> 1` (二进制 `11...10110` -\> `11...11011`) = -5
      * **用途**：替代除以 2 的运算。
  * **`>>>` (Logical Shift)**：**忽略符号位，高位统统补 0**。
      * `-10 >>> 1` 会变成一个巨大的正数（`Integer.MAX_VALUE` 附近）。
      * **用途**：哈希计算、位图操作、不关心正负的纯二进制处理。

> **陷阱**：移位数的模运算。
> 如果 `int x = 1; x << 33;` 结果是多少？
> Java 规定，对于 `int`，实际移动位数是 `k % 32`；对于 `long`，是 `k % 64`。
> 所以 `1 << 33` 等价于 `1 << 1`，结果是 2，而不是 0。

### 4.2 位运算实战技巧

#### 1\. 权限控制 (Masking)

JDK 中的 `Modifier` 类（判断 `public`, `static`, `final`）大量使用了这种技巧。

```java
int READ = 1 << 0;  // 1 (0001)
int WRITE = 1 << 1; // 2 (0010)
int EXEC = 1 << 2;  // 4 (0100)

int userPerm = READ | WRITE; // 赋权: 0011 (读+写)

// 鉴权: (perm & MASK) == MASK
boolean canRead = (userPerm & READ) == READ; // true
boolean canExec = (userPerm & EXEC) == EXEC; // false
```

#### 2\. 判断奇偶

```java
// 普通写法
if (n % 2 == 1) ...

// 高效写法
if ((n & 1) == 1) ...
```

原理：二进制的最后一位如果是 1，则是奇数；如果是 0，则是偶数。

#### 3\. HashMap 的索引计算 (深度)

在 JDK 7/8 的 `HashMap` 中，为了将 Hash 值映射到数组下标 `i`，没有使用低效的取模 `hash % length`，而是使用了：

```java
i = (length - 1) & hash;
```

**前提**：数组长度 `length` 必须是 **2 的幂次方**。
**原理**：当 `length` 是 2 的幂（如 16，即 `10000`）时，`length - 1` 是 `15`（即 `01111`）。
`hash & 01111` 刚好就是取 `hash` 值的低 4 位，这在数学上完全等价于 `hash % 16`，但位运算效率快几十倍。

-----

## 第五章：三元运算符 (Ternary Operator)

语法：`条件 ? 表达式1 : 表达式2`

### 5.1 自动拆箱引发的 NPE

```java
Integer a = null;
int b = true ? a : 0; // 抛出 NullPointerException
```

**分析**：

1.  表达式2 是 `int` (基本类型)。
2.  表达式1 是 `Integer` (包装类型)。
3.  根据 JLS 规范，当三元运算符的一边是基本类型，另一边是包装类型时，**包装类型会被强制拆箱**以匹配基本类型。
4.  `a` 自动拆箱调用 `a.intValue()`，因为 `a` 是 null，所以崩了。

### 5.2 类型对齐陷阱

我们在第一章稍微提过，这里再次强调：

```java
Object o = true ? 1 : 2.0;
System.out.println(o); // 1.0
```

JVM 会寻找两个表达式类型的**公共父类型**或进行**数值提升**。`int` 会提升为 `double`，所以结果变成了浮点数。在涉及金额计算时，这会导致精度问题。

-----

## 预告

在下一篇《Java 运算符与流程控制（三）》中，我们将进入**流程控制**的深水区。我们将剖析 **Switch 表达式**在 JDK 17+ 中的完整形态，揭秘 `for-each` 循环的语法糖本质，并探讨 `break` / `continue` 与标签（Label）的冷门用法。

**关注我，带你读懂 Java 字节码里的秘密。**

```
```
