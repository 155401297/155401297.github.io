这是《Java 容器与数据结构：从入门到入魔》系列的第四篇。

在上一篇中，我们无情地揭露了 `LinkedList` 在现代硬件上的性能短板。今天，我们将挑战 Java 集合框架中**最复杂、最核心、也是面试官最爱问**的 Boss 级容器——**HashMap**。

不仅仅是 `put` 和 `get`，我们将深入二进制的世界，看 JDK 的工程师如何用位运算榨干 CPU 的最后一点性能，以及 JDK 8 为什么要引入红黑树来重构这个使用了十几年的经典结构。

-----

## layout: post title:  "Java 容器与数据结构（四）：HashMap 的红黑树进化论与位运算魔法" date:   2025-11-28 10:00:00 +0800 categories: [Java, 容器源码, 底层原理] tags: [HashMap, 红黑树, 哈希碰撞, 位运算, 扰动函数]

## 系列前言

这是《Java 容器与数据结构：从入门到入魔》系列的第四篇。如果说 `ArrayList` 是士兵，那么 `HashMap` 就是军队的指挥中枢。它是 Java 工程师日常开发中使用频率最高的数据结构，没有之一。它的设计思想涵盖了哈希算法、链表、红黑树、位运算以及概率论，是源码阅读的必修课。

## 第一章：索引的魔法——为什么是 2 的幂？

HashMap 的底层首先是一个数组（Bucket Array）。当你 `put(key, value)` 时，第一步就是要算出这个 key 应该放在数组的哪个格子里。

### 1.1 取模 vs 位运算

最直观的计算方法是取模：`index = hash(key) % length`。
但是在计算机中，**除法（取模）运算的效率远低于位运算**。

JDK 的设计师做了一个极其巧妙的规定：**HashMap 的数组长度（Capacity）必须永远是 2 的幂次方**（16, 32, 64...）。

在这个前提下，取模运算可以被优化为位运算：

$$index = HashCode(key) \ \& \ (Length - 1)$$

**原理演示**：
假设 Length = 16 ($2^4$)，即二进制 `10000`。
Length - 1 = 15，即二进制 `01111`。

```text
  HashCode: 10101010 11000101
& Length-1: 00000000 00001111
-----------------------------
  Index   : 00000000 00000101 (即 5)
```

**结论**：`&` 运算直接截取了 HashCode 的**低位**。这比 `%` 运算快几十倍。这也是为什么我们在初始化 HashMap 时，如果你传入 `new HashMap(10)`，JDK 会自动帮你通过 `tableSizeFor` 方法把 10 变成 16。

-----

## 第二章：扰动函数——为了对抗碰撞

既然索引计算只依赖 HashCode 的**低位**（比如长度 16 时只看最后 4 位），那如果有一批 Key，它们的 HashCode 低位完全一样，高位不同，岂不是会全部碰撞在一起？

```text
Key A: 11110000 00000101 -> & 15 -> 5
Key B: 00001111 00000101 -> & 15 -> 5 (碰撞！)
```

### 2.1 `hash()` 方法的黑盒

为了解决这个问题，HashMap 并没有直接使用 `Object.hashCode()`，而是自己实现了一个 `hash()` 方法来进行“扰动”：

```java
// JDK 8 源码
static final int hash(Object key) {
    int h;
    // 让高 16 位与低 16 位进行异或 (XOR)
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

**设计的艺术**：
通过 `h >>> 16` 将高位的信息右移到低位，然后通过 `^` (异或) 混合在一起。
这样做的目的是：**让 HashCode 的高位也参与到低位的数组下标计算中**。即使 Table 的长度很小，高位的变化也能影响到最终的下标，从而让元素分布得更均匀。

-----

## 第三章：JDK 1.7 的死循环与 JDK 8 的红黑树

### 3.1 链表法 (Chaining)

当发生哈希碰撞时（两个 Key 算出了同一个 Index），HashMap 使用**链表**将它们串起来。
在 JDK 1.7 及以前，这就是全部了。

**致命缺陷**：
如果黑客精心构造了几万个 HashCode 相同的 Key 发起攻击（Hash DoS 攻击），链表会变得无限长。

  * **正常情况**：查询复杂度 O(1)。
  * **最坏情况**：链表过长，查询退化为 **O(N)**。服务器 CPU 直接 100%。

此外，JDK 1.7 采用**头插法**，在并发扩容时容易形成**环形链表**，导致 `get()` 方法陷入死循环（Infinite Loop）。

### 3.2 JDK 8 的进化：红黑树 (Red-Black Tree)

JDK 8 引入了革命性的变化：

1.  **尾插法**：解决了并发扩容的死循环问题（虽然 HashMap 依然不是线程安全的）。
2.  **树化 (Treeify)**：
    当链表长度超过阈值（**TREEIFY\_THRESHOLD = 8**）且数组长度大于 64 时，链表会转变为**红黑树**。

**性能提升**：

  * **红黑树查询复杂度**：**O(log N)**。
  * 即使发生严重的哈希碰撞，查找速度也仅仅是从“极快”变成了“比较快”，而不会直接卡死服务器。

-----

## 第四章：为什么阈值是 8？(泊松分布)

这是一个高频面试题：**为什么不是 6 或者 10，偏偏是 8？**

源码注释中提到了 **泊松分布 (Poisson Distribution)**。

简单来说：
在理想的随机哈希算法下，两个 Key 碰撞进同一个桶的概率极低。

  * 一个桶里有 1 个节点的概率是最高的。
  * 达到 8 个节点的概率已经小于 **千万分之一** (0.00000006)。

**工程权衡**：

  * **TreeNode (红黑树节点)** 的内存占用是 **Node (链表节点)** 的 **2 倍**。
  * JDK 的逻辑是：通常情况下，链表长度很难达到 8。如果真的达到了 8，说明哈希冲突已经非常严重了（可能是 Hash 算法太烂，或者遭到了攻击），此时牺牲一点内存空间，换取 O(log N) 的时间复杂度保护，是值得的。

-----

## 第五章：扩容的黑科技——高低位指针

当 HashMap 元素数量超过 `Capacity * LoadFactor` (默认 16 \* 0.75 = 12) 时，会触发扩容 (`resize`)，数组长度翻倍。

在 JDK 1.7 中，扩容需要重新计算每个元素的 Hash 值 (`rehash`)，非常耗时。
但在 JDK 8 中，利用 **2 次幂** 的特性，有一个极其精妙的优化：

因为长度翻倍（例如 16 -\> 32），下标计算从 `hash & 15` 变成了 `hash & 31`。
二进制也就是从 `01111` 变成了 `011111`。
**区别仅仅在于第 5 位（新增的高位）是 0 还是 1。**

  * **是 0**：元素位置不变（索引还是 5）。
  * **是 1**：元素位置 = 原位置 + 原数组长度（索引变成 5 + 16 = 21）。

**代码实现**：
JDK 8 不需要重新计算 Hash，只需要判断 `(e.hash & oldCap) == 0`。
它维护了两个链表：`loHead` (低位链表) 和 `hiHead` (高位链表)。遍历完旧桶后，直接把这两个链表分别挂到新数组的 `j` 和 `j + oldCap` 位置。

这消除了 Rehash 的开销，极其优雅。

-----

## 总结与预告

HashMap 是 Java 工程师必须征服的高山：

1.  **数组索引**：利用 $2^n$ 长度将取模转化为位运算 `&`。
2.  **扰动函数**：利用异或 `^` 和移位 `>>>` 让高位参与运算，减少碰撞。
3.  **红黑树**：用 O(log N) 的结构兜底，防止 O(N) 的性能退化。
4.  **扩容优化**：利用高低位判断，避免全量 Rehash。

但是，HashMap **不是线程安全的**。在多线程环境下，它可能丢失数据，甚至抛出异常。我们该如何保证并发安全？使用笨重的 `Hashtable` 还是 `Collections.synchronizedMap`？

不，我们有更强大的武器。

**下一篇预告**：
我们将剖析并发编程中的神作——**ConcurrentHashMap**。
它是如何抛弃了 JDK 1.7 的分段锁（Segment），转身拥抱 CAS 和 `synchronized` 锁升级策略的？敬请期待《Java 容器与数据结构（五）：ConcurrentHashMap 的并发艺术——从分段锁到 CAS 的进化》。
