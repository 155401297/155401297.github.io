这是《Java 并发与多线程：从入门到入魔》系列的第七篇。

在上一篇中，我们用 `CompletableFuture` 解决了异步编排的问题。但在追求极致性能的领域（如高频交易、核心日志系统），JDK 原生的 `ArrayBlockingQueue` 依然显得太慢了。哪怕是无锁的 `ConcurrentLinkedQueue`，在高并发下也会因为频繁的 CAS 冲突和 GC 压力导致性能抖动。

今天，我们要剖析一个“甚至不属于 JDK 标准库”的神器——**Disruptor**。它是 LMAX 交易所开源的高性能队列，也是 Log4j 2 性能吊打 Log4j 1 的秘密武器。我们将深入 CPU 缓存行的微观世界，看看它是如何利用“填充”来消除伪共享的。

-----

## layout: post title:  "Java 并发与多线程（七）：Disruptor 的环形缓冲区与伪共享的黑魔法" date:   2025-12-06 10:00:00 +0800 categories: [Java, 并发编程, 性能优化] tags: [Disruptor, RingBuffer, 伪共享, 缓存行, 无锁队列]

## 系列前言

这是《Java 并发与多线程：从入门到入魔》系列的第七篇。当我们在谈论性能时，通常指的是“毫秒级”。但在 Disruptor 的世界里，单位是“纳秒级”。它通过极致的**硬件亲和性 (Hardware Affinity)** 设计，将单线程的吞吐量推向了每秒数百万甚至上千万。

## 第一章：JDK 队列的软肋

为什么我们需要 Disruptor？看看 JDK 自带的队列：

1.  **`ArrayBlockingQueue`**: 基于数组，但使用了 `ReentrantLock`（一把大锁或两把锁）。在高并发下，**锁竞争**和**上下文切换**是性能杀手。
2.  **`LinkedBlockingQueue`**: 基于链表。虽然并发度好一点，但每次插入都要 `new Node`，导致大量**垃圾回收 (GC)** 压力；且链表节点内存不连续，**缓存命中率**极低。

LMAX 的工程师发现，要实现单机百万 TPS，必须解决两个问题：**锁** 和 **CPU 缓存失效**。

-----

## 第二章：环形缓冲区 (RingBuffer)

Disruptor 的核心数据结构不是队列，而是一个**预分配**的环形数组——**RingBuffer**。

### 2.1 永不 GC

这一点非常暴躁。`RingBuffer` 在启动时就会把数组里的所有对象（Event）一次性 `new` 好。

  * **生产数据时**：不是 `new Event()`，而是从数组里直接取出这个对象，修改它的属性。
  * **消费数据时**：读完数据，不需要销毁对象，它留在原地等待下一次被覆盖。

**结果**：在系统运行过程中，Disruptor **几乎不产生任何垃圾**，GC 停顿几乎为零。

### 2.2 下标计算的位运算

和 `HashMap` 一样，Disruptor 要求数组长度必须是 **2 的幂**。
这意味着它可以用 `sequence & (length - 1)` 替代取模运算，极速定位数组下标。

-----

## 第三章：伪共享 (False Sharing) —— 真正的黑魔法

这是 Disruptor 最著名的优化，也是面试官最喜欢问的底层知识。

### 3.1 缓存行 (Cache Line)

我们在讲 JMM 时提到过，CPU 读取内存是以 **Cache Line** 为单位的，通常是 **64 字节**。
假设我们有两个变量 `long A` 和 `long B`（各占 8 字节）。如果它们在内存中离得很近，它们很有可能被加载到**同一个 Cache Line** 中。

### 3.2 互相伤害

1.  **核心 1** 修改变量 A。它会锁定这个 Cache Line，并将其标记为“脏”。
2.  **核心 2** 想要读取变量 B。虽然 B 没变，但因为 B 和 A 在同一行，**整行缓存失效了**。核心 2 必须重新从主内存（L3）加载这一行。
3.  **核心 2** 修改变量 B，又导致核心 1 的缓存失效。

这种现象叫**伪共享**。A 和 B 逻辑上没关系，但物理上“同居”了，导致两个线程互相争抢缓存行的所有权，性能暴跌。

### 3.3 解决方案：缓存行填充 (Padding)

Disruptor 的解决方式非常“空间换时间”：**在变量前后强行塞入 7 个 `long` (56 字节)**。

```java
class LhsPadding {
    long p1, p2, p3, p4, p5, p6, p7; // 前填充
}

class Value extends LhsPadding {
    volatile long value; // 真正的核心变量
}

class RhsPadding extends Value {
    long p9, p10, p11, p12, p13, p14, p15; // 后填充
}
```

这样一来，无论 `value` 怎么放，它都独占一个 Cache Line。别的变量绝对挤不进来。
*注：JDK 8 提供了 `@Contended` 注解来实现同样的效果，但原理是一样的。*

-----

## 第四章：无锁并发的极致 —— 序号栅栏 (SequenceBarrier)

Disruptor 号称“无锁”，那它是怎么保证多线程安全的？

**核心机制：Sequence (序号)**。
这是一个递增的 `AtomicLong`。

1.  **生产者**：

      * 通过 CAS 获取下一个写入序号 `n`。
      * 获取成功后，**独占** `RingBuffer[n]` 这个槽位，慢慢填充数据，不需要担心别人抢。
      * 填完后，发布序号。

2.  **消费者**：

      * 消费者维护自己的序号。
      * 它会盯着生产者的序号（或者上游消费者的序号）。
      * 使用 `SequenceBarrier` 等待：只要生产者的序号大于我的序号，说明有新数据了，我就处理。

这种\*\*“一个写，多个读”**或者**“分槽位写”\*\*的模式，彻底抛弃了锁，只有轻量级的 CAS 和 volatile 读写。

-----

## 第五章：等待策略 (Wait Strategy)

当消费者处理得太快，追上了生产者怎么办？它需要等待。Disruptor 提供了多种策略：

1.  **BlockingWaitStrategy**：使用 `Lock` 和 `Condition` 等待。最慢，但最省 CPU。
2.  **SleepingWaitStrategy**：先自旋，再 `Thread.yield()`，最后 `LockSupport.parkNanos()`。性能和 CPU 的折中，**Log4j2 默认用这个**。
3.  **BusySpinWaitStrategy**：**死循环自旋**。延迟最低，但吃满一个 CPU 核心。适用于在此机器上该线程绑定了独立物理核的场景。

-----

## 总结与预告

Disruptor 将性能压榨到了物理极限：

1.  **数据结构**：RingBuffer 环形数组，内存预分配，零 GC。
2.  **内存布局**：缓存行填充 (Padding)，消灭伪共享。
3.  **并发控制**：基于 Sequence 的 CAS 和栅栏机制，消灭锁竞争。

学完 Disruptor，我们对单机并发性能的挖掘已经到了尽头。但是，随着 Java 21 的发布，Java 的并发模型迎来了一次**维度上的打击**。

我们一直在努力复用线程（线程池），因为线程太重了。那如果线程变得像对象一样轻量级呢？如果我们可以毫不心疼地开启 100 万个线程呢？

**下一篇预告**：
我们将迎来本系列的终章（或新篇章的开始）。Java 21 的**虚拟线程 (Virtual Threads / Project Loom)** 到底是什么？它如何改变了“一个请求一个线程”的编程范式？Reactive 响应式编程还会存在吗？敬请期待《Java 并发与多线程（八）：虚拟线程 (Loom) —— 百万并发的终极答案》。
